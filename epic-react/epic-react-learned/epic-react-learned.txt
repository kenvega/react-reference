fundamentals

  how do you manage DOM nodes using javascript?
    normally you might need to use these or more functions

      createElement
      getElementById
      setAttribute
      append

    example

      <body>
        <script type="module">
          // setting root div
          const rootElement = document.createElement('div')
          rootElement.setAttribute('id', 'root')
          document.body.append(rootElement)

          // appending hello world to root div
          const div = document.createElement('div')
          div.textContent = 'Hello world'
          div.className = 'container'
          rootElement.append(div)
        </script>
      </body>


    sources to look at:

      about the script tag
        https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attributes
        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules
        https://github.com/mdn/js-examples/tree/master/modules

      the js functions that handle DOM
        https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
        https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById
        https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/append

  how do you create and render elements with the raw React API?

    you will need to use these methods
      React.createElement
      ReactDOM.render

    these methods need the library react and react-dom

    example of a nested structure created with raw React API

      const rootElement = document.getElementById('root')

      const span1 = React.createElement('span', {children: 'Hello'})
      const span2 = React.createElement('span', {children: 'World'})

      const containerElement = React.createElement('div', {
        className: 'container',
        children: [span1, span2], // children can be a single primitive value or an array
      })

      ReactDOM.render(containerElement, rootElement)

  what does createElement returns in pure javascript?

    it returns an object that you can log the console

      some of their properties are
        $$typeof - to indicate that is in fact a react element
        key
        props - the second argument object that you pass to createElement
        ref
        type - the type of the html element that will be rendered. e.g. div

  is there a difference between creating elements with jsx and the raw react api?

    it seems it doesn't
      this code creates a react element with its raw api
        const element = React.createElement('div', {
          className: 'container',
          children: 'Hello World',
        })

      this code creates a react element with jsx
        const element = <div className="container">Hello World</div>

      both can be rendered to the page with the render method
        ReactDOM.render(element, document.getElementById('root'))

      you could console.log both elements and will get an object with the same properties

  what does babel does when imported as a script?

    it will search for any script tags with type="text/babel" and it will compile it
      javascript actually won't do anything to those script types

    babel can for example compile your jsx code to javascript code that uses the raw React API
      e.g.
        const ui = <h1 id="greeting">Hey there</h1>

      gets transformed to
        const ui = React.createElement('h1', {id: 'greeting', children: 'Hey there'})

    you can tests more examples here: https://babeljs.io/repl

    you can import babel in your html file and use it to transpile your code directly in your browser
      but this should only be for testing and not for production
      for production you pre compile your code and then send the compiled version to the browser

  jsx

    can be converted by babel to regular javascript

    it's an alternative to create your react elements without using the raw React API

    it is similar to html but also it lets you use javascript at the same time
      so you can create html tags like before but you can also interpolate javascript with that

    because it uses javascript keywords there are some element tags that have some specific changes

      - the class for a tag cannot be named class. instead use className

      - the for attribute on a label is renamed to htmlFor

      - more differences can be found at: https://reactjs.org/docs/dom-elements.html#differences-in-attributes

    if you use the in-browser babel version to test (imported script tag in your html file)
      you can inspect your browser and find the compiled version from your jsx code to a regular javascript code
        this compiled version was made by babel and it is what the browser actually understands

    you can create a react element with jsx, assign it to a javascript variable and log it
      and you will get the exact same object you get when creating that object with the raw React API

    so your babel code with jsx end up being compiled to a script tag inside in the head tag of your html file
      then that compiled version uses regular raw React API

    you cannot do statements inside of jsx directly because in the end remember that there is going to be a conversion
      to the raw React API which is createReactElement which recieve 3 arguments
        those arguments can only be in the end values... and cannot be statements... so no way to set statements inside jsx

  so in summary until now, to make react work
    you need React library to create react elements
    you need react-dom to put those react elements to the page
    and you need babel to create them with jsx instead of the raw React API

  react components
    basically they are just functions that return a react element that is going to be rendered

  you can also make React.createElement receive a function instead of a string
    - when recieving a string it will generate an html tag with that name
    - when recieving a function it will render what that function returns (see extra credit 1 - exercise 4)
        to avoid errors with this use an uppercase letter function. This way the function is treated as a react component
          JSX syntax specification: uppercase elements tags are treated as references to a variables in scope

  styling React components
    you can style by creating css in a file, importing it and applying it with classNames

    you can also style by adding a `style` prop to the html tags 

  forms

    the onSubmit attribute is set for forms so that you can handle what happens
      here you can prevent the default behavior of forms (the full refresh page)

    React creates and uses synthetic events instead of regular events in the DOM for performance reasons
      but the difference between them you won't notice in daily use

    console.dir - use it to log the properties instead of a DOM node (useful for event.target)

    when inputs have an id, you can refer to them by that id from your event

      <input id="usernameInputId" ... />

      event.elements.usernameInputId.value

    controlled vs uncontrolled inputs
      controlled form inputs
        React has a state that rules what the input should be
        You will need to pass a value and an onChange prop to the input to make it work

        for controlled inputs you should also have a default value for the input and not null
          else you get a warning

      uncontrolled inputs
        the input works as regular inputs
        the browser manages the input value, we just query that value and get notified by changes
          that's why you can only have an onChange prop on the input for this

  rendering arrays
    rendering an array of renderable elements is possible in jsx
      but they have an implication when those elements in the array change over time

      when you re-render that array with an element added, React doesn't know if you added that element at the start, the middle or the end of the array

        visual example

          initArray = [1,2,3,4,5]

          addedArray = [1,2,3,6,4,5]

          you could know that 6 was added by comparing to the old array but that would be inefficient I think as it will have to go through N elements
        


