fundamentals

  how do you manage DOM nodes using javascript?
    normally you might need to use these or more functions

      createElement
      getElementById
      setAttribute
      append

    example

      <body>
        <script type="module">
          // setting root div
          const rootElement = document.createElement('div')
          rootElement.setAttribute('id', 'root')
          document.body.append(rootElement)

          // appending hello world to root div
          const div = document.createElement('div')
          div.textContent = 'Hello world'
          div.className = 'container'
          rootElement.append(div)
        </script>
      </body>


    sources to look at:

      about the script tag
        https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attributes
        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules
        https://github.com/mdn/js-examples/tree/master/modules

      the js functions that handle DOM
        https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
        https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById
        https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/append

  how do you create and render elements with the raw React API?

    you will need to use these methods
      React.createElement
      ReactDOM.render

    these methods need the library react and react-dom

    example of a nested structure created with raw React API

      const rootElement = document.getElementById('root')

      const span1 = React.createElement('span', {children: 'Hello'})
      const span2 = React.createElement('span', {children: 'World'})

      const containerElement = React.createElement('div', {
        className: 'container',
        children: [span1, span2], // children can be a single primitive value or an array
      })

      ReactDOM.render(containerElement, rootElement)

  what does createElement returns in pure javascript?

    it returns an object that you can log the console

      some of their properties are
        $$typeof - to indicate that is in fact a react element
        key
        props - the second argument object that you pass to createElement
        ref
        type - the type of the html element that will be rendered. e.g. div

  is there a difference between creating elements with jsx and the raw react api?

    it seems it doesn't
      this code creates a react element with its raw api
        const element = React.createElement('div', {
          className: 'container',
          children: 'Hello World',
        })

      this code creates a react element with jsx
        const element = <div className="container">Hello World</div>

      both can be rendered to the page with the render method
        ReactDOM.render(element, document.getElementById('root'))

      you could console.log both elements and will get an object with the same properties

  what does babel does when imported as a script?

    it will search for any script tags with type="text/babel" and it will compile it
      javascript actually won't do anything to those script types

    babel can for example compile your jsx code to javascript code that uses the raw React API
      e.g.
        const ui = <h1 id="greeting">Hey there</h1>

      gets transformed to
        const ui = React.createElement('h1', {id: 'greeting', children: 'Hey there'})

    you can tests more examples here: https://babeljs.io/repl

    you can import babel in your html file and use it to transpile your code directly in your browser
      but this should only be for testing and not for production
      for production you pre compile your code and then send the compiled version to the browser

  jsx

    can be converted by babel to regular javascript

    it's an alternative to create your react elements without using the raw React API

    it is similar to html but also it lets you use javascript at the same time
      so you can create html tags like before but you can also interpolate javascript with that

    because it uses javascript keywords there are some element tags that have some specific changes

      - the class for a tag cannot be named class. instead use className

      - the for attribute on a label is renamed to htmlFor

      - more differences can be found at: https://reactjs.org/docs/dom-elements.html#differences-in-attributes

    if you use the in-browser babel version to test (imported script tag in your html file)
      you can inspect your browser and find the compiled version from your jsx code to a regular javascript code
        this compiled version was made by babel and it is what the browser actually understands

    you can create a react element with jsx, assign it to a javascript variable and log it
      and you will get the exact same object you get when creating that object with the raw React API

    so your babel code with jsx end up being compiled to a script tag inside in the head tag of your html file
      then that compiled version uses regular raw React API

    you cannot do statements inside of jsx directly because in the end remember that there is going to be a conversion
      to the raw React API which is createReactElement which recieve 3 arguments
        those arguments can only be in the end values... and cannot be statements... so no way to set statements inside jsx

  so in summary until now, to make react work
    you need React library to create react elements
    you need react-dom to put those react elements to the page
    and you need babel to create them with jsx instead of the raw React API

  react components
    basically they are just functions that return a react element that is going to be rendered

  you can also make React.createElement receive a function instead of a string
    - when recieving a string it will generate an html tag with that name
    - when recieving a function it will render what that function returns (see extra credit 1 - exercise 4)
        to avoid errors with this use an uppercase letter function. This way the function is treated as a react component
          JSX syntax specification: uppercase elements tags are treated as references to a variables in scope

  styling React components
    you can style by creating css in a file, importing it and applying it with classNames

    you can also style by adding a `style` prop to the html tags 

  forms

    the onSubmit attribute is set for forms so that you can handle what happens
      here you can prevent the default behavior of forms (the full refresh page)

    React creates and uses synthetic events instead of regular events in the DOM for performance reasons
      but the difference between them you won't notice in daily use

    console.dir - use it to log the properties instead of a DOM node (useful for event.target)

    when inputs have an id, you can refer to them by that id from your event

      <input id="usernameInputId" ... />

      event.elements.usernameInputId.value

    controlled vs uncontrolled inputs
      controlled form inputs
        React has a state that rules what the input should be
        You will need to pass a value and an onChange prop to the input to make it work

        for controlled inputs you should also have a default value for the input and not null
          else you get a warning

      uncontrolled inputs
        the input works as regular inputs
        the browser manages the input value, we just query that value and get notified by changes
          that's why you can only have an onChange prop on the input for this

  rendering arrays
    rendering an array of renderable elements is possible in jsx
      but they have an implication when those elements in the array change over time

      when you re-render that array with an element added or removed
        React doesn't know if you added/removed that element at the start, middle or end of the array

      it's best explained here https://reactjs.org/docs/reconciliation.html#recursing-on-children
        where you see that React tries to avoid re-creating a tree of React elements where it can so that it is more efficient
          but when you change an array of renderable elements adding one at the start
            React could not notice that it can avoid re-creating some trees of React elements and it mutates most of them instead
              with keys React knows that elements just "moved" and it doesn't have to re-create them again

      React doesn't know what caused a particular change in the jsx that you are returning
        all that it knows is that the jsx was changed and it does a guess based on the changes that you provided

      also as best practice never use indexes of your arrays as the keys
        if you use indexes as keys then you will see problems if you array state needs to be reordered
        in fact using the array indexes is the default mechanism that react has to render arrays and it warns you about it 

react hooks

  intro

    most common hooks to use
      React.useState
      React.useEffect
      React.useContext
      React.useRef
      React.useReducer

    some hooks return a value (like useRef or useContext) while others return a pair of values in an array (like useState, useReducer)
      some don't return nothing at all (like useEffect)

  useState

    when you call the setState function the component re-renders

    you can pass a function to useState hook to avoid making a expensive computation every single time
      and instead just do it in the first time the component is rendered (this sound like useEffect (?))

      instead of using
        React.useState(someExpensiveComputation())
      use
        React.useState(() => someExpensiveComputation())

      note:
        this is only to avoid expensive computations when setting the initial value of the state that don't need to be recalculated every render

  useEffect

    lets you run custom code after React renders or re-renders your component

    there are many cases where components get re-rendered
      - parent gets re-rendered
      - a state changes

      if you need to run your effects only when specific state changes, you can pass those to the dependency arrays of your useEffect hook

    you should not send objects in the array of dependencies of useEffect hooks
      because to detect if there was changes between your variables inside the effect and the array of dependencies it React does a shallow comparison
        so it does something like a triple equals to compare (===)
          and comparing objects that have exact same keys/values with triple equals never gets true